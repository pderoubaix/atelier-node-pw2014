<!DOCTYPE html><html lang="en"><head><title>models/comment</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="models/comment"><meta name="groc-project-path" content="models/comment.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">models/comment.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="modle--commentaire">Modèle : Commentaire</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le mode strict c’est le bien…</p></div></div><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>;

<span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="schma">Schéma</h2>
<p>Mongoose nous fait définir des <a href="http://mongoosejs.com/docs/guide.html">schémas</a>
qui représentent la structure, les règles, la validation et les
extensions de méthodes de nos documents.  C’est extrêmement utile, et
les possibilités sont particulièrement riches.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> commentSchema = mongoose.Schema({</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>« Clé étrangère » (voyez l’attribut <code>ref</code> qui reprend le nom du modèle associé)
pour l’auteur.  Comme les clés primaires pour <code>User</code> sont des <code>String</code> et non des
<code>ObjectID</code>, on suit le mouvement ici.</p></div></div><div class="code"><div class="wrapper">  author:   { type: <span class="hljs-built_in">String</span>, ref: <span class="hljs-string">'User'</span>, required: <span class="hljs-literal">true</span> },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Date d’envoi, avec une fonction pour fournir une valeur par défaut si besoin.
Remarquez qu’on <em>référence</em> <code>Date.now</code> mais qu’on ne l’appelle pas.  Et Mongoose
est assez malin pour appeler <code>new Date</code> automatiquement sur le résultat de l&#39;appel
le moment venu (<code>Date.now</code> renvoie un <code>Number</code>).  Notez aussi qu&#39;on en fait un index
(c&#39;est pas parce qu&#39;on est en NoSQL qu&#39;on n&#39;a pas d&#39;indexes pour optimiser les perfs)
vu qu&#39;on sait pertinemment qu&#39;on va toujours trier.</p></div></div><div class="code"><div class="wrapper">  postedAt: { type: <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">default</span>: <span class="hljs-built_in">Date</span>.now, index: <span class="hljs-literal">true</span> },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le texte du commentaire.  Remarquez les petits plus de confort de Mongoose, genre
l’attribut <code>trim</code>, qui va auto-<em>trimmer</em> notre texte (et ne pas planter si celui-ci
est à la base <code>undefined</code> ou <code>null</code>) <em>avant</em> de vérifier sa présence au titre de la
contrainte <code>required</code>.</p></div></div><div class="code"><div class="wrapper">  text:     { type: <span class="hljs-built_in">String</span>, trim: <span class="hljs-literal">true</span>, required: <span class="hljs-literal">true</span> }
});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="mthodes-statiques-custom">Méthodes statiques custom</h2>
<p>Tout ajout à la propriété <code>statics</code> du schéma équipe les modèles dérivés de ces méthodes
statiques.  On aurait la même chose en mode instance avec la propriété <code>methods</code> du schéma.</p></div></div><div class="code"><div class="wrapper">_.extend(commentSchema.statics, {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>getAll</code>, utilisé par <code>listComments</code> dans le <a href="../controllers/comments.js">contrôleur des commentaires</a>,
est juste une surcouche légère du <code>find()</code> de Mongoose (ici sans critères) qui prend juste
soin de pré-remplir (<em>eager loading</em>) les auteurs et de trier le plus récent d&#39;abord.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>En terminant par <code>.exec()</code>, on termine la chaîne de requêtage/affinage pour produire une
<a href="http://www.html5rocks.com/fr/tutorials/es6/promises/">promesse</a> associée, ce qui rend le
code appelant plus confortable à écrire.</p></div></div><div class="code"><div class="wrapper">  getAll: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllComments</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find().populate(<span class="hljs-string">'author'</span>).sort({ postedAt: -<span class="hljs-number">1</span> }).exec();
  }
});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="export-du-modle">Export du modèle</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Chaque module de modèle publie un modèle Mongoose basé sur le schéma ainsi défini.
Pour en savoir plus sur la distinction entre schéma et modèle dans Mongoose,
<a href="http://mongoosejs.com/docs/models.html">jetez un œil par ici</a>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = mongoose.model(<span class="hljs-string">'Comment'</span>, commentSchema);</div></div></div></div></body></html>